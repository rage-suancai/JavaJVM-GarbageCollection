垃圾回收算法
前面我们介绍了对象存活判定算法 现在我们已经可以准确地知道堆中的哪些对象可以被回收了 那么 接下来就该考虑如何对对象进行回收了
垃圾收集器会不定期地检查堆中的对象 查看它们是否满足被回收的条件 我们该如何对这些对象进行回收 是一个一个判断是否需要回收吗?

分代收集机制
实际上 如果我们对堆中的每一个对象都依次判断是否需要回收 这样的效率其实是很低的 那么有没有更好地回收机制呢 第一步 我们可以对堆中的对象进行分代管理

比如某些对象 在多次垃圾回收时 都未被判定可回收对象 我们完全可以将这一部分对象放在一起 并让垃圾收集器减少回收此区域对象的频率 这样就能很好地提高垃圾回收的效率了

因此 java虚拟机将堆内存划分为新生代 老年代和永久代 (其中永久代是HotSpot虚拟机特有的概念 在JDK8之前方法区域实际上就是采用的永久代作为实现
而在JDK8之后 方法区由元空间实现 并且使用的是本地内存 容量大小取决于物理机实际大小 之后会详细介绍) 这里我们主要讨论的是新生代和老年代

不同的分代内存回收机制也存在一些不同之处 在HotSpot虚拟机中 新生代被划分为三块 一块较大的Eden空间和两块较小的Survivor空间 默认比例为 8: 1: 1
老年代的GC频率相对较低 永久代一般存放类信息等(其实就是方法区的实现) 如下所示:

                                                         java堆内存
                           --------------------------------------------------------------------
                                         新生代                |--------------------||---------|
                           --------------------------------   |                    ||         |
                                                 Survivor     |                    ||         |
                           |-----------------|------|-----|   |       老年代        ||  永久代  |
                           |       Eden      | From | To  |   |                    ||         |
                           |                 |      |     |   |                    ||         |
                           |-----------------|------|-----|   |--------------------||---------|

那么它是如何运作的呢?

首先 所有新创建的对象 在一开始都会进入到新生代的Eden区(如果是大对象会被直接丢进老年代) 在进行新生代区域的垃圾回收时 首先会对所有新生代区域对象进行扫描 并回收那些不再使用的对象:

                                             新生代                                                             新生代
                           ----------------------------------------                         ----------------------------------------
                                                         Survivor                                                         Survivor
                           |--------------------------||----||----|                         |--------------------------||----||----|
                           |  [对象1]     [对象3]       ||    ||    |                        |  [对象1]                   ||    ||   |
                           |                          ||    ||    |                         |                          ||    ||    |
                           |    我们都是刚出生的乖宝宝    ||Form|| To | --------垃圾回收-------->|       3号4号落地成盒        ||From|| To |
                           |                          ||    ||    |                         |                          ||    ||    |
                           |  [对象4]      [对象2]      ||    ||    |                        |                 [对象2]   ||    ||    |
                           |--------------------------||----||----|                         |--------------------------||----||----|

接着 在一次垃圾回收之后 Eden区域没有被回收的对象 会进入到Survivor区 在一开始From和To都是空的 而GC之后 所有Eden区域存活的对象都会直接被放入到From区
最后From和To会发生一次交换 也就是说目前存放我们对象的From区 变为To区 而To区变为From区

                                                新生代                                                                新生代
                           ----------------------------------------------                      ----------------------------------------------
                                                            Survivor                                                            Survivor
                           |-------------------------||--------|--------|                      |-------------------------||--------|--------|
                           |                         || [对象2] |        |                      |                         || [对象2]|        |
                           |                         ||        |        |                      |                         ||        |        |
                           |          Eden           ||  From  |   To   | ----交换To和From----> |           Eden          ||   To   |  From  |
                           |                         ||        |        |                      |                         ||        |        |
                           |                         || [对象1] |        |                      |                         || [对象1]|        |
                           |-------------------------||--------|--------|                      |-------------------------||--------|--------|

接着就是下一次垃圾回收了 操作与上面是一样的 不过这时由于我们From区域中已经存在对象了 所以 在Eden区的存活对象复制到From区之后
所有To区域中的对象会进行年龄判断 (每经历一轮GC年龄+1 如果对象的年龄大于(默认值为15) 那么会直接进入到老年代 否则移动到From区)

                                                新生代                                                                新生代
                           ----------------------------------------------                      ----------------------------------------------
                                                            Survivor                                                            Survivor
                           |-------------------------||--------|--------|                      |-------------------------||--------|--------|
                           |                         || [对象2] |        |                      |                         ||        | [对象2] |
                           |                         ||        |        |                      |                         ||        |        |
                           |          Eden           ||   To   |  From  | -----再来一轮GC-----> |           Eden          ||   To   |  From  |
                           |                         ||        |        |                      |                         ||        | [对象5] |
                           |   [对象5]                || [对象1] |        |                      |                         ||        | [对象1] |
                           |-------------------------||--------|--------|                      |-------------------------||--------|--------|


最后像上面一样交换To区和From区 之后不断重复以上步骤

而垃圾收集也分为:
    > Minor GC - 次要垃圾回收 主要进行新生代区域的垃圾收集
        > 触发条件: 新生代的Eden区容量已满时
    > Major GC - 主要垃圾回收 主要进行老年代的垃圾收集
    > Full GC - 完全垃圾回收 对整个java堆内存和方法区进行垃圾回收
        > 触发条件1: 每次普升到老年代的对象平均大小大于老年代剩余空间
        > 触发条件2: Minor GC后存活的对象超过了老年代剩余空间
        > 触发条件3: 永久代内存不足(JDK8之前)
        > 触发条件4: 手动调用System.gc()方法

我们可以添加启动参数来查看JVM的GC日志:
                    -XX:+PrintGCDetails

                    public static void main(String[] args) {

                        Object o = new Object();
                        o = null;
                        System.gc

                    }

                    [GC (System.gc()) [PSYoungGen: 3853K->904K(74240K)] 3853K->912K(243712K), 0.0013998 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
                    [Full GC (System.gc()) [PSYoungGen: 904K->0K(74240K)] [ParOldGen: 8K->694K(169472K)] 912K->694K(243712K), [Metaspace: 3291K->3291K(1056768K)], 0.0038961 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
                    Heap
                     PSYoungGen      total 74240K, used 1920K [0x000000076dd80000, 0x0000000773000000, 0x00000007c0000000)
                      eden space 64000K, 3% used [0x000000076dd80000,0x000000076df601a8,0x0000000771c00000)
                      from space 10240K, 0% used [0x0000000771c00000,0x0000000771c00000,0x0000000772600000)
                      to   space 10240K, 0% used [0x0000000772600000,0x0000000772600000,0x0000000773000000)
                     ParOldGen       total 169472K, used 694K [0x00000006c9800000, 0x00000006d3d80000, 0x000000076dd80000)
                      object space 169472K, 0% used [0x00000006c9800000,0x00000006c98ad8c0,0x00000006d3d80000)
                     Metaspace       used 3299K, capacity 4496K, committed 4864K, reserved 1056768K
                      class space    used 352K, capacity 388K, committed 512K, reserved 1048576K

现在我们还只能大致看懂GC日志 不过再学习完成本章全部内容后 我们就可以轻松阅读了

空间分配担保
我们可以思考一下 有没有这样一种极端情况(正常情况下新生代的回收率是很高的 所以说不用太担心会经常出现这种问题) 在一次GC后 新生代Eden区仍然存在大量的对象
(因为GC之后存活对象会进入到一个Survivor区 但是很明显这时已经超出Survivor区的容量了 肯定是装不下的) 那么现在该怎么办

这时就需要用到空间分配担保机制了 可以吧Survivor区无法容纳的对象直接送到老年代 让老年代分配担保(当然老年代也得装得下才行)在现实生活中 贷款会指定担保人
就是当借钱人还不起钱的时候由担保人来还钱 当新生代无法容纳更多的对象时 可以把新生代中的对象移动到老年代中 这样新生代就腾出了空间来容纳更多的对象

好 那既然新生代装不下就丢给老年代 那么要是老年代也装不下新生代的数据呢 这时 老年代肯定担保人是当不成了 那么这样的话
首先会判断一下之前的每次垃圾回收进入老年代的平均大小是否小于当前老年代的剩余空间 如果小于 那么说明也许可以放得下(不过也仅仅是也许 依然有可能放不下
因为判断的实际上只是平均值 万一这一次突然非常大呢) 否则 会先来一次Full GC 进行一次大规模垃圾回收 来尝试腾出空间 再次判断老年代是否有空间存放 要是还是装不下 直接抛出OOM错误 摆烂
