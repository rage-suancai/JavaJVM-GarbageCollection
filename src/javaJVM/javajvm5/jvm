垃圾收集器实现
聊完了对象存活判定和垃圾回收算法 接着我们就要看看具体有哪些垃圾回收器的实现了 我们可以自由地为新生代和老年代选择更适合它们的收集器

Serial收集器
这款垃圾收集器也是元老级别的收集器了 在JDK1.3.1之前 是虚拟机新生代区域收集器的唯一选择 这是一款单线程的垃圾收集器 也就是说
当开始进行垃圾回收时 需要暂停所有的线程 直到垃圾收集器工作结束 它的新生代收集器算法采用的是标记复制算法 老年代采用的是标记整理算法

                      CPU 0 ---用户线程1---> |           GC线程            |---用户线程1--->|           GC线程          |---用户线程1--->
                      CPU 1 ---用户线程2---> | -------------------------> |---用户线程2--->| ------------------------->|---用户线程2--->
                      CPU 2 ---用户线程3---> |      新生代采取复制算法       |---用户线程3--->|     老年代采取标记-整理算法   |---用户线程3--->
                      CPU 3 ---用户线程4---> |       暂停所有用户线程        |---用户线程4--->|       暂停所有用户线程       |---用户线程4--->
                                        Safepoint                                   Safepoint

可以看到 当进入到垃圾回收阶段时 所有的用户线程必须等待GC线程完成工作 就相当于你打一把LOL 40分钟
中途每隔1分钟网络就卡5秒钟 可能这时你正在打团 结果你被物理控制直接在那里站了5秒钟 这确实让人难以接受

虽然缺点很明显 但是优势也是显而易见的:
    1. 设计简单而高效
    2. 在用户的桌面应用场景中 内一般不大 可以在较短时间内完成垃圾收集 只要不频繁发生 使用串行回收器是可以接受的

所以 在客户端模式(一般用于桌面级图形化界面引用程序)下的新生代中 默认垃圾收集器至今依然是Seriall收集器 我们可以通过命令java -version查看默认的客户端模式:
                    java version "14.0.2" 2020-07-14
                    Java(TM) SE Runtime Environment (build 14.0.2+12-46)
                    Java HotSpot(TM) 64-Bit Server VM (build 14.0.2+12-46, mixed mode, sharing)

我们可以在jvm.cfg文件中切换JRE为Server VM或是Client VM 默认路径为:
                    JDK安装目录\Java\jdk-14.0.2\lib\jvm.cfg

比如我们需要将当前模式切换为客户端模式 那么我们可以这样编辑:
                    -client KNOWN
                    -server IGNORE

ParNew收集器
这款垃圾收集器相当于是Serial收集器的多线程版本 它能够支持多线程垃圾收集:

                                              新生代采取复制算法                    老年代采取整理算法
                                               暂停所有用户线程                      暂停所有用户线程
                      CPU 0 ---用户线程1---> | -----GC线程-----> |---用户线程1--->|                   |---用户线程1--->
                      CPU 1 ---用户线程2---> | -----GC线程-----> |---用户线程2--->| -----GC线程-----> |---用户线程2--->
                      CPU 2 ---用户线程3---> | -----GC线程-----> |---用户线程3--->|                   |---用户线程3--->
                      CPU 3 ---用户线程4---> | -----GC线程-----> |---用户线程4--->|                   |---用户线程4--->
                                       Safepoint                          Safepoint

除了多线程支持以外 其他内容基本与Serial收集器一致 并且目前某些JVM默认的服务端模式新生代收集器就是使用的ParNew收集器

Parallel Scavenge/Parallel Old收集器
Parallel Scavenge同样是一款面向新生代的垃圾收集器 同样采用标记复制算法实现 在JDK16时也推出了其老年代收集器Parallel Old 采用标记整理算法实现:

                                              新生代采取复制算法                    老年代采取整理算法
                                               暂停所有用户线程                      暂停所有用户线程
                      CPU 0 ---用户线程1---> | -----GC线程-----> |---用户线程1--->| -----GC线程-----> |---用户线程1--->
                      CPU 1 ---用户线程2---> | -----GC线程-----> |---用户线程2--->| -----GC线程-----> |---用户线程2--->
                      CPU 2 ---用户线程3---> | -----GC线程-----> |---用户线程3--->| -----GC线程-----> |---用户线程3--->
                      CPU 3 ---用户线程4---> | -----GC线程-----> |---用户线程4--->| -----GC线程-----> |---用户线程4--->
                                       Safepoint                          Safepoint

与ParNew收集器不同的是 它会自动衡量一个吞吐量 并根据吞吐量来决定每次垃圾回收的时间 这种自适应机制 能够很好地权衡当前机器的性能 根据性能选最优方案

目前JDK8采用的就是这种Parallel Scavenge + Parallel Old的垃圾回收方案

CMS收集器
在JDK1.5 HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器: CMS(Concurrent-Mark-Sweep)收集器
这款收集器是HotSpot虚拟机中第一款真正意义上的的并发(注意: 这里的并发合和之前的并行是有区别的 并发可以理解为同时运行用户线程和GC线程 而并行可以理解为多条GC线程同时工作) 收集器 它第一次实现了让垃圾收集线程与用户线程同时工作

它主要采用标记清除算法:
                      CPU 0 ---用户线程1---> |               |---用户线程1--->|---重新标记--->|---用户线程1--->|---用户线程1--->
                      CPU 1 ---用户线程2---> | ---初始标记---> |---用户线程2--->|---重新标记--->|---用户线程2--->|---用户线程2--->
                      CPU 2 ---用户线程3---> |               |---并发标记---> |---重新标记--->|---并发清理---> |---重置线程--->
                      CPU 3 ---用户线程4---> |               |---用户线程4--->|---重新标记--->|---用户线程4--->|---用户线程4--->

它的垃圾回收分为4个阶段:
    > 初始标记(需要暂停用户线程): 这个阶段的主要任务仅仅只是标记出GC Roots能直接管理到的对象 速度比较快 不用担心会停顿太长时间
    > 并发标记: 从GC Roots的直接关联对象开始遍历整个对象图的过程 这个过程耗时较长但是不需要停顿用户线程 可以与垃圾收集线程一起并发运行
    > 重新标记(需要暂停用户线程): 由于并发标记阶段可能某些用户线程会导致标记产生变化因此这里需要再次暂停所有线程进行并行标记 这个时间会比初始标记时间长一丢丢
    > 并发清除: 最后就可以直接将所有标记好的无用对象进行删除 因为这些对象程序中也用不到了 所以可以与用户线程并发运行

虽然它的优点非常之大 但是缺点也是显而易见的 我们之前说过 标记清除算法会产生大量的内存碎片 导致可用连续空间逐渐变少 长期这样下来
会有更高的概率触发Full GC 并且在与用户线程并发执行的情况下 也会占用一部分的系统资源 导致用户线程的运行速度一定程度上减慢

不过 如果你希望的是最低的GC停顿时间 这款垃圾收集器无疑是最佳选择 不过自从G1收集器问世之后 CMS收集器不再推荐使用了

Garbage First(G1)收集器
此垃圾收集器是一款划时代的垃圾收集器 在JDK7的时候走上历史舞台 它是一款主要面向于服务端的垃圾收集器 并且在JDK9时 取代了JDK8默认的Parallel Scavenge + Parallel Old的回收方案

我们知道 我们的垃圾回收分为Minor GC Major GC和Full GC它们分别对应的是新生代 老年代和整个堆内存的垃圾回收 而G1收集器巧妙地绕过了这些约定 它将整个java堆划分成2048个大小相同的独立Region块
每个Region块的大小根据堆空间的实际大小而定 整体被控制在1MB到32MB之间 且都为2的N次幂 所有的Region大小相同 且在JVM的整个生命周期内不会发生改变

那么分出这些Region有什么意义呢 每一个Region都可以根据需要 自由决定扮演哪个角色(Eden Survivor和老年代) 收集器会根据对应的角色采用不同的回收策略
此外 G1收集器还存在一个Humongous区域 它专门用于存放大对象(一般认为大小超过了Region容量一半的对象为大对象) 这样 新生代 老年代在物理上 不再是一个连续的内存区域 而是到处分布的

它的回收过程与CMS大体类似 分为以下四个步骤:
    > 初始标记(需要暂停用户线程): 仅仅只是标记一下GC Roots能直接关联到的对象 并且修改TAMS指针的值 让下一阶段用户线程并发运行时 能正确地在可用的Region中分配新对象
                              这个阶段需要停顿线程 但耗时很短 而且是借用进行Minor GC的时候同步完成的 所以G1收集器在这个阶段实际并没有额外的停顿
    > 并发标记: 从GC Roots开始对堆中对象进行可达性分析 递归扫描整个堆里面的对象图 找出要回收的对象 这阶段耗时较长 但可与用户程序并发执行
    > 最终标记(暂停用户线程): 对用户线程做一短暂的暂停 用于处理并发标记阶段漏标的那部分对象
    > 筛选回收: 负责更新Region的统计数据 对各个Region的回收价值和成本进行排序 根据用户所期望的停顿时间来定制回收计划 可用自由选择任意多个Region构成回收集 然后把决定
               回收的那一部分Region的存活对象复制到空的Region中 再清理掉整个旧Region的全部空间 这里的操作涉及存活对象的移动 是必须暂停用户线程 由多个收集器线程并行完成的