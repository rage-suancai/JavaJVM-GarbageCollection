垃圾回收机制
注意: 此部分为重点内容

我们前面提到 java会自动管理和释放内存 它不像C/C++那样要求我们手动管理内存 JVM提供了一套全自动的内存管理机制 当一个java对象不再用到时
JVM会自动将其回收并释放内存 那么对象所占内存在什么时候被回收 如何判定对象可以被回收 以及如何去进行回收工作也是JVM需要关注的问题

对象存活判定算法
首先我们来讨论第一个问题 也就是: 对象在什么情况下可以被判定为不再使用已经可以回收了? 这里就需要提到以下几种垃圾回收算法了:

                                                    java堆内存
                              ---------------------------------------------------
                                String对象    Set对象    Double对象    Integer对象
                                Object对象    Map对象    Boolean对象   List对象

引用计数法
我们知道 如果我们要经常检查一个对象 那么首先一定会创建一个引用变量:
                    // str就是一个引用类型的变量 它持有对前后面字符串对象的引用 可以代表后面这个字符串对象本身
                    String str = "yxsnb";

                    // str.xxx...

实际上 我们会发现 只要一个对象还有使用价值 我们就会通过它的引用变量来进行操作 那么可否这样判断一个对象是否还需要被使用:
    > 每个对象都包含一个引用计数器 用于存放引用计数(其实就是存放引用的次数)
    > 每当有个地方引用此对象时 引用计数+1
    > 当引用失效(比如离开了局部变量的作用域或是引用被设定为null)时 引用计数-1
    > 当引用计数为0时 表示此对象不可能再被使用 因为这时我们已经没有任何方法可以得到此对象的引用了

但是这样存在一个问题 如果两个对象相互引用呢?
                    private static class Test {
                            Test another;
                        }

                    public static void main(String[] args) {

                        Test a = new Test();
                        Test b = new Test();

                        a.another = b;
                        b.another = a;

                        a = b = null; // 这里直接把a和b赋值为null 这样前面的两个对象我们不可能再得到了

                    }

按照引用计数器算法 那么当出现以上情况时 虽然我们无法在得到此对象的引用了并且此对象我们也无需再使用 但是由于这两个对象直接存在相互引用的情况
那么引用计数器的值将会永远是1 但是实际上此对象已经没有任何用途了 所以引用计数器并不是最好的解决方案

可达性分析算法
目前比较主流的编程语言(包括java) 一般都会使用可达性分析算法来判断对象是否存活 它采用了类似树结构的搜索机制

首先每对象的引用都有机会成为树的根节点(GC Roots) 可以被选定作为根节点条件如下:
    > 位于虚拟机栈的栈帧中的本地变量表中所引用到的对象(其实就是我们方法中的局部变量) 同样也包括本地方法栈中JNI引用的对象
    > 类的静态成员变量引用的对象
    > 方法区中常量池里面引用的对象 比如我们之前提到的String类型对象
    > 被添加了锁的对象(比如synchronized关键字)
    > 虚拟机内部需要用到的对象

                                                根节点集合
                                               [GC Roots]
                                                   |
                                                   | 比如某个局部变量引用了对象1
                                                   |
                                                 [对象1]
                                                   |
                                                   | 对象之间也可能存在引用
                                        ___________|___________
                                        |                     |
                                        |                     |
                                      [对象2]                [对象3]

一旦已经存在的根节点不满足存在的条件时 那么根节点与对象之间的连接被断开 此时虽然对象1仍存在其他对象的引用
但是由于其没有任何根节点引用 所以此对象即可被判定为不再使用 比如某个方法中的局部变量引用 在方法执行完成返回之后:

                                                根节点集合
                                                  [X]
                                                   |
                                                   | 方法执行完毕 栈帧此时已经不在虚拟机栈中 不再满足GC Roots的条件 所以关联被断开
                                                   |
                                                 [对象1] ------------> 使命结束 可以被回收
                                                   |
                                                   | 对象之间也可能存在引用
                                        ___________|___________
                                        |                     |
                                        |                     |
                                      [对象2]                [对象3]

这样就能很好地解决我们刚刚提到的循环引用问题 我们再来重现一下出现循环引用的情况:

                                                根节点集合
                                      [GC Roots]        [GC Roots]
                                          |                 |
                                          |                 |
                                          |                 |
                                       [对象1] <---------> [对象2]

可以看到 对象1和对象2依然是存在循环引用的 但是只有他们各自的GC Roots断开 那么就会变成下面这样:

                                                根节点集合
                                             [X]        [X]
                                       --------------------------
                                       [对象1] <----------> [对象2]
                           即使存在循环引用 但是它们各自都不存在GC Roots 所以可以被回收

所以 我们最后进行一下总结: 如果某个对象无法到达任何GC Roots 则证明此对象是不可能再被使用的